{"remainingRequest":"/Users/francescamorini/projects/transition-v2/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/francescamorini/projects/transition-v2/src/components/EmissionsChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/francescamorini/projects/transition-v2/src/components/EmissionsChart.vue","mtime":1571598903382},{"path":"/Users/francescamorini/projects/transition-v2/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-v2/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-v2/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-v2/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCi8vIExpYnJhcmllcwppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4JwoKLy8gY29tcG9uZW50cwppbXBvcnQgTGluZXMgZnJvbSAnLi9zdWJjb21wb25lbnRzL0RvdExpbmVzLnZ1ZScKCi8vIERhdGEKaW1wb3J0IGVtaXNzaW9uc0RhdGEgZnJvbSAnLi4vYXNzZXRzL2RhdGEvZW1pc3Npb25zLmpzb24nCmltcG9ydCBzdWJFbWlzc2lvbnNEYXRhIGZyb20gJy4uL2Fzc2V0cy9kYXRhL2VtaXNzaW9ucy1zdGFja2VkLmpzb24nCgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0VtaXNzaW9uc0NoYXJ0JywKICBjb21wb25lbnRzOiB7CiAgICBMaW5lcwogIH0sCiAgcHJvcHM6IHsKICAgIHdpZHRoOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0sCiAgICBoZWlnaHQ6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfQogIH0sCiAgZGF0YSAoKSB7CiAgICByZXR1cm4gewogICAgICBncmFwaFNpemU6IHsKICAgICAgICB3aWR0aDogdGhpcy53aWR0aCwKICAgICAgICBoZWlnaHQ6IDYwMAogICAgICB9LAogICAgICBtYXJnaW46IHsKICAgICAgICB0b3A6IDIwLAogICAgICAgIHJpZ2h0OiAyMCwKICAgICAgICBib3R0b206IDIwLAogICAgICAgIGxlZnQ6IDIwCiAgICAgIH0sCiAgICAgIGVtaXNzaW9uc0RhdGEsCiAgICAgIHN1YkVtaXNzaW9uc0RhdGEsCiAgICAgIGxpbmU6ICcnCiAgICB9CiAgfSwKICBtb3VudGVkICgpIHsKICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZW1pc3Npb25zRGF0YSkKICAgIHRoaXMuY2FsY0xpbmUoKQogIH0sCiAgbWV0aG9kczogewogICAgZ2V0U2NhbGUgKCkgewogICAgICBjb25zdCBlbWlzc2lvbnMgPSB0aGlzLmVtaXNzaW9uc0RhdGEKICAgICAgY29uc3QgcGFyc2VEYXRlID0gZDMudGltZVBhcnNlKCclWScpCiAgICAgIGVtaXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgZC5kYXRlID0gcGFyc2VEYXRlKGQuWWVhcikKICAgICAgfSkKCiAgICAgIHZhciB4ID0gZDMKICAgICAgICAuc2NhbGVUaW1lKCkKICAgICAgICAuZG9tYWluKFtkMy5taW4oZW1pc3Npb25zLCBkID0+IGQuZGF0ZSksIHBhcnNlRGF0ZSgyMDgwKV0pCiAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMud2lkdGggLSAyMDBdKQoKICAgICAgdmFyIHkgPSBkMwogICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgLmRvbWFpbihbMCwgNDAwMDAwMDBdKQogICAgICAgIC5yYW5nZShbdGhpcy5oZWlnaHQgLyAyLCAtMTAwXSkKCiAgICAgIHJldHVybiB7CiAgICAgICAgcGFyc2VEYXRlLAogICAgICAgIHgsCiAgICAgICAgeQogICAgICB9CiAgICB9LAogICAgY2FsY0xpbmUgKCkgewogICAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKQogICAgICBjb25zdCBwYXRoID0gZDMKICAgICAgICAubGluZSgpCiAgICAgICAgLngoZCA9PiB7IHJldHVybiBzY2FsZS54KGQuZGF0ZSkgfSkKICAgICAgICAueShkID0+IHsgcmV0dXJuIHNjYWxlLnkoZC5FbWlzc2lvbnMpIH0pCiAgICAgICAgLmN1cnZlKGQzLmN1cnZlTGluZWFyKQogICAgICB0aGlzLmxpbmUgPSBwYXRoKGVtaXNzaW9uc0RhdGEpCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLi4ubWFwU3RhdGUoewogICAgICBzdGVwOiBzdGF0ZSA9PiBzdGF0ZS5zY3JvbGx5dGVsbGluZyA/IHN0YXRlLnNjcm9sbHl0ZWxsaW5nLnN0ZXAgOiBudWxsCiAgICB9KSwKICAgIHNlY3RvckNodW5rcyAoKSB7CiAgICAgIGNvbnN0IHNlY3RvcnMgPSBbJ0VsZWN0cmljaXR5JywgJ090aGVyRW5lcmd5JywgJ0luZHVzdHJ5JywgJ1RyYW5zcG9ydHMnLCAnQnVpbGRpbmcnXQogICAgICAvLyBjb25zdCBjb2xvcnMgPSBbJyMzMzEyMWMnLCAnIzYxMTczMScsICcjOTMxNTQ3JywgJyNkZDVmODQnLCAnI2VkOTZhYiddCiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnN1YkVtaXNzaW9uc0RhdGEKICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCkKICAgICAgY29uc3QgcGFyc2VEYXRlID0gc2NhbGUucGFyc2VEYXRlCgogICAgICBkYXRhLmZvckVhY2goKGQpID0+IHsgZC5kYXRlID0gcGFyc2VEYXRlKGQuWWVhcikgfSkKCiAgICAgIGNvbnN0IGFyZWFzWCA9IGQzCiAgICAgICAgLmFyZWEoKQogICAgICAgIC54KGQgPT4geyByZXR1cm4gc2NhbGUueChkLmRhdGUpIH0pCiAgICAgICAgLmN1cnZlKGQzLmN1cnZlTGluZWFyKQoKICAgICAgY29uc3Qgc2VjdG9yc0FyZWFzID0gc2VjdG9ycy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHsKICAgICAgICBhcmVhc1gKICAgICAgICAgIC55MChkID0+IHsKICAgICAgICAgICAgbGV0IHN1bSA9IDAKICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpOyBuKyspIHsKICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBkW3NlY3RvcnNbbl1dCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnkoc3VtKQogICAgICAgICAgfSkKICAgICAgICAgIC55MShkID0+IHsKICAgICAgICAgICAgbGV0IHN1bSA9IDAKICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPD0gaTsgbisrKSB7CiAgICAgICAgICAgICAgc3VtID0gc3VtICsgZFtzZWN0b3JzW25dXQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzY2FsZS55KHN1bSkKICAgICAgICAgIH0pCgogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkOiBhcmVhc1goZGF0YSksCiAgICAgICAgICBpZDogc2VjdG9yc1tpXQogICAgICAgICAgLy8gY29sb3I6IGNvbG9yc1tdCiAgICAgICAgfQogICAgICB9KQogICAgICBjb25zb2xlLmxvZyhzZWN0b3JzQXJlYXMpCiAgICAgIHJldHVybiBzZWN0b3JzQXJlYXMKICAgIH0KICB9LAogIGRpcmVjdGl2ZXM6IHsKICAgIGF4aXMgKGVsZW1lbnQsIGJpbmQpIHsKICAgICAgY29uc3QgYXhpcyA9IGJpbmQuYXJnCiAgICAgIGNvbnN0IGF4aXNNZXRob2QgPSB7IHg6ICdheGlzQm90dG9tJywgeTogJ2F4aXNMZWZ0JyB9W2F4aXNdCiAgICAgIGNvbnN0IG1ldGhvZEFyZyA9IGJpbmQudmFsdWVbYXhpc10KICAgICAgZDMuc2VsZWN0KGVsZW1lbnQpLmNhbGwoZDNbYXhpc01ldGhvZF0obWV0aG9kQXJnKSkKICAgIH0KICB9Cn0K"},{"version":3,"sources":["EmissionsChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;AAeA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"EmissionsChart.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"visualization\" id=\"emissions__chart\">\n    <svg :width='this.graphSize.width' :height='this.graphSize.height'>\n      <g :transform=\"`translate(${this.width/6},${this.height/4})`\">\n        <g class=\"axis\" v-axis:x=\"getScale()\" :transform=\"`translate(0,${height / 2})`\"></g>\n        <g class=\"axis\" v-axis:y=\"getScale()\"></g>\n        <Lines />\n        <path id=\"emissions\" :d='line' />\n        <path v-for=\"(chunk, i) in sectorChunks\" v-bind:key='i' :d='chunk.d' :id='chunk.id' class=\"emission__chunks\"/>\n      </g>\n    </svg>\n  </div>\n</template>\n\n<script>\n// Libraries\nimport * as d3 from 'd3'\nimport { mapState } from 'vuex'\n\n// components\nimport Lines from './subcomponents/DotLines.vue'\n\n// Data\nimport emissionsData from '../assets/data/emissions.json'\nimport subEmissionsData from '../assets/data/emissions-stacked.json'\n\nexport default {\n  name: 'EmissionsChart',\n  components: {\n    Lines\n  },\n  props: {\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    }\n  },\n  data () {\n    return {\n      graphSize: {\n        width: this.width,\n        height: 600\n      },\n      margin: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n      },\n      emissionsData,\n      subEmissionsData,\n      line: ''\n    }\n  },\n  mounted () {\n    // console.log(this.emissionsData)\n    this.calcLine()\n  },\n  methods: {\n    getScale () {\n      const emissions = this.emissionsData\n      const parseDate = d3.timeParse('%Y')\n      emissions.forEach(function (d) {\n        d.date = parseDate(d.Year)\n      })\n\n      var x = d3\n        .scaleTime()\n        .domain([d3.min(emissions, d => d.date), parseDate(2080)])\n        .rangeRound([0, this.width - 200])\n\n      var y = d3\n        .scaleLinear()\n        .domain([0, 40000000])\n        .range([this.height / 2, -100])\n\n      return {\n        parseDate,\n        x,\n        y\n      }\n    },\n    calcLine () {\n      const scale = this.getScale()\n      const path = d3\n        .line()\n        .x(d => { return scale.x(d.date) })\n        .y(d => { return scale.y(d.Emissions) })\n        .curve(d3.curveLinear)\n      this.line = path(emissionsData)\n    }\n  },\n  computed: {\n    ...mapState({\n      step: state => state.scrollytelling ? state.scrollytelling.step : null\n    }),\n    sectorChunks () {\n      const sectors = ['Electricity', 'OtherEnergy', 'Industry', 'Transports', 'Building']\n      // const colors = ['#33121c', '#611731', '#931547', '#dd5f84', '#ed96ab']\n      const data = this.subEmissionsData\n      const scale = this.getScale()\n      const parseDate = scale.parseDate\n\n      data.forEach((d) => { d.date = parseDate(d.Year) })\n\n      const areasX = d3\n        .area()\n        .x(d => { return scale.x(d.date) })\n        .curve(d3.curveLinear)\n\n      const sectorsAreas = sectors.map(function (item, i) {\n        areasX\n          .y0(d => {\n            let sum = 0\n            for (let n = 0; n < i; n++) {\n              sum = sum + d[sectors[n]]\n            }\n            return scale.y(sum)\n          })\n          .y1(d => {\n            let sum = 0\n            for (let n = 0; n <= i; n++) {\n              sum = sum + d[sectors[n]]\n            }\n            return scale.y(sum)\n          })\n\n        return {\n          d: areasX(data),\n          id: sectors[i]\n          // color: colors[]\n        }\n      })\n      console.log(sectorsAreas)\n      return sectorsAreas\n    }\n  },\n  directives: {\n    axis (element, bind) {\n      const axis = bind.arg\n      const axisMethod = { x: 'axisBottom', y: 'axisLeft' }[axis]\n      const methodArg = bind.value[axis]\n      d3.select(element).call(d3[axisMethod](methodArg))\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n@import \"library/src/style/variables.scss\";\n\n#emissions {\n  stroke: getColor(red, 40);\n  fill: none;\n}\n\n.axis >>> g.tick > line {\n  stroke: black;\n  font-family: $font-mono;\n}\n\n.emission__chunks {\n  fill: $color-pale-gray;\n  stroke: $color-red;\n}\n\n</style>\n"]}]}