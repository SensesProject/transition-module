{"remainingRequest":"/Users/francescamorini/projects/transition-module/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/francescamorini/projects/transition-module/src/components/marimekko-emissions.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/francescamorini/projects/transition-module/src/components/marimekko-emissions.vue","mtime":1572536223177},{"path":"/Users/francescamorini/projects/transition-module/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwppbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnCmltcG9ydCBBeGlzIGZyb20gJy4vYXhpcy52dWUnCmltcG9ydCBDYXJyaWVyUGF0aCBmcm9tICcuL2NhcnJpZXJzU2VsUGF0aHMudnVlJwoKaW1wb3J0IGVtaXNzaW9uc1N1YnNlY3RvcnMgZnJvbSAnLi4vYXNzZXRzL3N1YnNlY3RvcnMtZW1pc3Npb25zLW5lc3QuanNvbicKaW1wb3J0IGVuZXJneUNhcnJpZXJzIGZyb20gJy4uL2Fzc2V0cy9lbmVyZ3ktY2FycmllcnMtd29ybGQuanNvbicKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnbWFyaW1la2tvRW1pc3Npb25zJywKICBjb21wb25lbnRzOiB7CiAgICBheGlzOiBBeGlzLAogICAgQ2FycmllclBhdGgKICB9LAogIGRhdGEgKCkgewogICAgcmV0dXJuIHsKICAgICAgc3Vic2VjdG9yczogZW1pc3Npb25zU3Vic2VjdG9ycywKICAgICAgY2FycmllcnM6IGVuZXJneUNhcnJpZXJzLAogICAgICBjaGFydERlZmF1bHRzOiB7CiAgICAgICAgd2lkdGg6IDEwMDAsCiAgICAgICAgaGVpZ2h0OiA3MDAsCiAgICAgICAgY2hhcnRJZDogJ3N1YmVtaXNzaW9ucycsCiAgICAgICAgdGl0bGU6ICdFbWlzc2lvbnMnLAogICAgICAgIG1hcmdpbjogewogICAgICAgICAgdG9wOiA1LAogICAgICAgICAgcmlnaHQ6IDUwLAogICAgICAgICAgYm90dG9tOiAyNSwKICAgICAgICAgIGxlZnQ6IDAKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGVtaXNzaW9uc0xhYmVsczogdGhpcy52aXNpYmxlTGFiZWxzLAogICAgICBzZWxlY3RlZDogbnVsbAogICAgfQogIH0sCiAgbWV0aG9kczogewogICAgc2VsZWN0IChldmVudCkgewogICAgICB2YXIgdGFyZ2V0SWQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmlkCiAgICAgIGlmICh0aGlzLnNlbGVjdGVkID09PSB0YXJnZXRJZCkgdGhpcy5zZWxlY3RlZCA9IG51bGwKICAgICAgZWxzZSB0aGlzLnNlbGVjdGVkID0gdGFyZ2V0SWQKICAgIH0sCiAgICB2aXNpYmxlTGFiZWxzICgpIHsKICAgICAgdmFyIHZpc2libGUKICAgICAgaWYgKHRoaXMuc3RlcCA9PT0gNSkgewogICAgICAgIHZpc2libGUgPSB0cnVlCiAgICAgICAgcmV0dXJuIHZpc2libGUKICAgICAgfSBlbHNlIHsKICAgICAgICB2aXNpYmxlID0gZmFsc2UKICAgICAgICByZXR1cm4gdmlzaWJsZQogICAgICB9CiAgICB9LAogICAgZ2V0U2NhbGUgKCkgewogICAgICBjb25zdCBzdWJzZWN0b3JzID0gdGhpcy5zdWJzZWN0b3JzCiAgICAgIGNvbnN0IGNhcnJpZXJzID0gdGhpcy5jYXJyaWVycwogICAgICBjb25zdCBjaGFydERlZmF1bHRzID0gdGhpcy5jaGFydERlZmF1bHRzCiAgICAgIGNvbnN0IHNlY3RvcnMgPSBbJ0VsZWN0cmljaXR5JywgJ0J1aWxkaW5nJywgJ0luZHVzdHJ5JywgJ1RyYW5zcG9ydCddCiAgICAgIHZhciBmaWx0ZXJFbGUgPSBzdWJzZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScgfSkKICAgICAgdmFyIGZpbHRlckJ1aWxkID0gc3Vic2VjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuU2VjdG9yID09PSAnQnVpbGRpbmcnIH0pCiAgICAgIHZhciBmaWx0ZXJJbmQgPSBzdWJzZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5TZWN0b3IgPT09ICdJbmR1c3RyeScgfSkKICAgICAgdmFyIGZpbHRlclRyID0gc3Vic2VjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuU2VjdG9yID09PSAnVHJhbnNwb3J0JyB9KQoKICAgICAgdmFyIHhQZXJjID0gZDMKICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgIC5kb21haW4oWzAsIDFdKQogICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmNoYXJ0RGVmYXVsdHMud2lkdGggLSA1MF0pCgogICAgICB2YXIgeFBlcmNMYWJlbHMgPSBkMwogICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgLmRvbWFpbihbMCwgMTBdKQogICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmNoYXJ0RGVmYXVsdHMud2lkdGggLSAxMDBdKQoKICAgICAgdmFyIHggPSBkMwogICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgLmRvbWFpbihbMCwgZmlsdGVyRWxlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbC5FbWlzc2lvbnMsIDApXSkKICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5jaGFydERlZmF1bHRzLndpZHRoIC0gNTBdKQoKICAgICAgdmFyIHhCID0gZDMKICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgIC5kb21haW4oWzAsIGZpbHRlckJ1aWxkLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbC5FbWlzc2lvbnMsIDApXSkKICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5jaGFydERlZmF1bHRzLndpZHRoIC0gNTBdKQoKICAgICAgdmFyIHhJID0gZDMKICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgIC5kb21haW4oWzAsIGZpbHRlckluZC5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuRW1pc3Npb25zLCAwKV0pCiAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuY2hhcnREZWZhdWx0cy53aWR0aCAtIDUwXSkKCiAgICAgIHZhciB4VCA9IGQzCiAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAuZG9tYWluKFswLCBmaWx0ZXJUci5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuRW1pc3Npb25zLCAwKV0pCiAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuY2hhcnREZWZhdWx0cy53aWR0aCAtIDUwXSkKCiAgICAgIHZhciBzY2FsZVhDYXIgPSBzZWN0b3JzLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkgewogICAgICAgIHZhciBzY2FsZUFycmF5CiAgICAgICAgdmFyIGNhcnJpZXJzU2NhbGUgPSBjYXJyaWVycy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuU2VjdG9yID09PSBpdGVtIH0pCiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPD0gaTsgbisrKSB7CiAgICAgICAgICBzY2FsZUFycmF5ID0gZDMKICAgICAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAgICAgLmRvbWFpbihbMCwgY2FycmllcnNTY2FsZS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuRW1pc3Npb25zLCAwKV0pCiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCBjaGFydERlZmF1bHRzLndpZHRoIC0gNTBdKQogICAgICAgIH0KICAgICAgICByZXR1cm4gc2NhbGVBcnJheQogICAgICB9KQoKICAgICAgdmFyIHkgPSBkMwogICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgLmRvbWFpbihbMCwgc3Vic2VjdG9ycy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuRW1pc3Npb25zLCAwKV0pCiAgICAgICAgLnJhbmdlKFswLCB0aGlzLmNoYXJ0RGVmYXVsdHMuaGVpZ2h0IC0gMzAwXSkKCiAgICAgIHZhciB5QSA9IGQzCiAgICAgICAgLnNjYWxlTGluZWFyKCkKICAgICAgICAuZG9tYWluKFswLCBzdWJzZWN0b3JzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbC5FbWlzc2lvbnMsIDApXSkKICAgICAgICAucmFuZ2UoWzAsIHRoaXMuY2hhcnREZWZhdWx0cy5oZWlnaHQgLSA5MF0pCgogICAgICBkMy5heGlzVG9wKCkuc2NhbGUoeEkpCiAgICAgIGQzLmF4aXNSaWdodCgpLnNjYWxlKHlBKQoKICAgICAgdmFyIGZvcm1hdFBlcmNlbnQgPSBkMy5mb3JtYXQoJy4wJScpCgogICAgICB2YXIgeEF4aXMgPSBkMwogICAgICAgIC5heGlzVG9wKCkKICAgICAgICAuc2NhbGUoeFBlcmMpCiAgICAgICAgLnRpY2tTaXplKDApCiAgICAgICAgLnRpY2tQYWRkaW5nKDEwKQogICAgICAgIC50aWNrVmFsdWVzKFswLCAxXSkKICAgICAgICAudGlja0Zvcm1hdChmb3JtYXRQZXJjZW50KQoKICAgICAgdmFyIHlBeGlzID0gZDMKICAgICAgICAuYXhpc1JpZ2h0KCkKICAgICAgICAuc2NhbGUoeUEpCiAgICAgICAgLnRpY2tzKDApCgogICAgICByZXR1cm4gewogICAgICAgIHgsCiAgICAgICAgeEF4aXMsCiAgICAgICAgeSwKICAgICAgICB4QiwKICAgICAgICB4SSwKICAgICAgICB4VCwKICAgICAgICBzY2FsZVhDYXIsCiAgICAgICAgeFBlcmMsCiAgICAgICAgeUF4aXMsCiAgICAgICAgeFBlcmNMYWJlbHMKICAgICAgfQogICAgfQogIH0sCiAgLy8gdGhpcyBjb21wdXRlZCBwcm9wZXJ0eSBuZWVkcyB0byBiZSBhZGRlZCBmb3IgdGhlIHNjcm9sbHl0ZWxsaW5nIHRvIGZ1bmN0aW9uCiAgY29tcHV0ZWQ6IHsKICAgIC4uLm1hcFN0YXRlKHsKICAgICAgc3RlcDogc3RhdGUgPT4gc3RhdGUuc2Nyb2xseXRlbGxpbmcgPyBzdGF0ZS5zY3JvbGx5dGVsbGluZy5zdGVwIDogbnVsbAogICAgfSksCiAgICBkYXR1bSAoKSB7CiAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwCiAgICAgIHZhciBkYXRhID0gdGhpcy5zdWJzZWN0b3JzCiAgICAgIGlmIChzdGVwID49IDYpIHsgcmV0dXJuIHRoaXMuY2FycmllcnMgfQogICAgICByZXR1cm4gZGF0YQogICAgfSwKICAgIC8vIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhbiBhcnJheSB0byBoYW5kbGUgc2luZ2xlIHNxdWFyZXMgYW5kIHRoZWlyIHZlcnRpY2FsIGhlaWdodCBhbmQgcG9zaXRpb24gb24gdGhlIHNjcmVlbgogICAgcmVjdHMgKCkgewogICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCkKICAgICAgdmFyIGRhdGFIZWlnaHQgPSB0aGlzLnN1YnNlY3RvcnMKICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdHVtCiAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwCiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQKCiAgICAgIGNvbnN0IHN1YmVtaXNzaW9uQXJyYXkgPSBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkgewogICAgICAgIGNvbnN0IGVtaXNzaW9uc1ZhbHVlID0gZCA9PiB7CiAgICAgICAgICBsZXQgc3VtID0gZGF0YVswXS5FbWlzc2lvbnMKICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaTsgbisrKSB7CiAgICAgICAgICAgIHN1bSA9IGl0ZW0uRW1pc3Npb25zCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RlcCA9PT0gNSkgewogICAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUueChzdW0pCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdCdWlsZGluZycpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUueEIoc3VtKQogICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VjdG9yID09PSAnSW5kdXN0cnknKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnhJKHN1bSkKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ1RyYW5zcG9ydCcpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUueFQoc3VtKQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPj0gNikgewogICAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUuc2NhbGVYQ2FyWzBdKHN1bSkKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ0J1aWxkaW5nJykgewogICAgICAgICAgICAgIHJldHVybiBzY2FsZS5zY2FsZVhDYXJbMV0oc3VtKQogICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VjdG9yID09PSAnSW5kdXN0cnknKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnNjYWxlWENhclsyXShzdW0pCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdUcmFuc3BvcnQnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnNjYWxlWENhclszXShzdW0pCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGNvbnN0IGRpc3RhbmNlVmFsdWUgPSBkID0+IHsKICAgICAgICAgIGxldCB0b3RhbCA9IDAKICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaTsgbisrKSB7CiAgICAgICAgICAgIGlmIChpdGVtLlNlY3RvciA9PT0gZGF0YVtuXS5TZWN0b3IpIHsKICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgZGF0YVtuXS5FbWlzc2lvbnMKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0ZXAgPT09IDUpIHsKICAgICAgICAgICAgaWYgKGl0ZW0uU2VjdG9yID09PSAnRWxlY3RyaWNpdHknKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLngodG90YWwpCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdCdWlsZGluZycpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUueEIodG90YWwpCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdJbmR1c3RyeScpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUueEkodG90YWwpCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdUcmFuc3BvcnQnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnhUKHRvdGFsKQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPj0gNikgewogICAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgICByZXR1cm4gc2NhbGUuc2NhbGVYQ2FyWzBdKHRvdGFsKQogICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VjdG9yID09PSAnQnVpbGRpbmcnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnNjYWxlWENhclsxXSh0b3RhbCkKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ0luZHVzdHJ5JykgewogICAgICAgICAgICAgIHJldHVybiBzY2FsZS5zY2FsZVhDYXJbMl0odG90YWwpCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdUcmFuc3BvcnQnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlLnNjYWxlWENhclszXSh0b3RhbCkKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgY29uc3QgaGVpZ2h0VmFsdWUgPSBkID0+IHsKICAgICAgICAgIGxldCBmaWx0ZXJFbGUgPSBkYXRhSGVpZ2h0LmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScgfSkKICAgICAgICAgIGxldCBmaWx0ZXJCdWlsZCA9IGRhdGFIZWlnaHQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLlNlY3RvciA9PT0gJ0J1aWxkaW5nJyB9KQogICAgICAgICAgbGV0IGZpbHRlckluZCA9IGRhdGFIZWlnaHQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLlNlY3RvciA9PT0gJ0luZHVzdHJ5JyB9KQogICAgICAgICAgbGV0IGZpbHRlclRyID0gZGF0YUhlaWdodC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuU2VjdG9yID09PSAnVHJhbnNwb3J0JyB9KQogICAgICAgICAgbGV0IGhlaWdodCA9IDAKICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDw9IGk7IG4rKykgewogICAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgICBoZWlnaHQgPSBmaWx0ZXJFbGUucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLkVtaXNzaW9ucywgMCkKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ0J1aWxkaW5nJykgewogICAgICAgICAgICAgIGhlaWdodCA9IGZpbHRlckJ1aWxkLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbC5FbWlzc2lvbnMsIDApCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdJbmR1c3RyeScpIHsKICAgICAgICAgICAgICBoZWlnaHQgPSBmaWx0ZXJJbmQucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLkVtaXNzaW9ucywgMCkKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ1RyYW5zcG9ydCcpIHsKICAgICAgICAgICAgICBoZWlnaHQgPSBmaWx0ZXJUci5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwuRW1pc3Npb25zLCAwKQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHNjYWxlLnkoaGVpZ2h0KQogICAgICAgIH0KCiAgICAgICAgY29uc3QgcG9zaXRpb25WYWx1ZSA9IGQgPT4gewogICAgICAgICAgdmFyIGJhc2lzUG9zaXRpb24gPSBoZWlnaHRWYWx1ZSgpCiAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgYmFzaXNQb3NpdGlvbiA9IGJhc2lzUG9zaXRpb24gKiAwCiAgICAgICAgICB9IGlmIChpdGVtLlNlY3RvciA9PT0gJ0luZHVzdHJ5JykgewogICAgICAgICAgICBiYXNpc1Bvc2l0aW9uID0gYmFzaXNQb3NpdGlvbiAqIDIuNwogICAgICAgICAgfSBpZiAoaXRlbS5TZWN0b3IgPT09ICdCdWlsZGluZycpIHsKICAgICAgICAgICAgYmFzaXNQb3NpdGlvbiA9IGJhc2lzUG9zaXRpb24gKiA0LjUKICAgICAgICAgIH0gaWYgKGl0ZW0uU2VjdG9yID09PSAnVHJhbnNwb3J0JykgewogICAgICAgICAgICBiYXNpc1Bvc2l0aW9uID0gYmFzaXNQb3NpdGlvbiAqIDUKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBiYXNpc1Bvc2l0aW9uCiAgICAgICAgfQoKICAgICAgICBjb25zdCByZWN0Q29sb3JzID0gZCA9PiB7CiAgICAgICAgICB2YXIgY29sb3IgPSAnIzAwMDAwMCcKICAgICAgICAgIGlmIChzdGVwID09PSA1KSB7CiAgICAgICAgICAgIGlmIChpdGVtLlNlY3RvciA9PT0gJ0VsZWN0cmljaXR5JykgewogICAgICAgICAgICAgIGNvbG9yID0gJyNmZmMwMjcnCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdJbmR1c3RyeScpIHsKICAgICAgICAgICAgICBjb2xvciA9ICcjZDk5OTAwJwogICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VjdG9yID09PSAnQnVpbGRpbmcnKSB7CiAgICAgICAgICAgICAgY29sb3IgPSAnI2E2NzUwMCcKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ1RyYW5zcG9ydCcpIHsKICAgICAgICAgICAgICBjb2xvciA9ICcjNzM1MTAwJwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPj0gNikgewogICAgICAgICAgICBpZiAoaXRlbS5TZWN0b3IgPT09ICdFbGVjdHJpY2l0eScpIHsKICAgICAgICAgICAgICBjb2xvciA9ICcjNThlNGEyJwogICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uU2VjdG9yID09PSAnSW5kdXN0cnknKSB7CiAgICAgICAgICAgICAgY29sb3IgPSAnIzAwYTY2ZScKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlY3RvciA9PT0gJ0J1aWxkaW5nJykgewogICAgICAgICAgICAgIGNvbG9yID0gJyMwMGM1OGMnCiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5TZWN0b3IgPT09ICdUcmFuc3BvcnQnKSB7CiAgICAgICAgICAgICAgY29sb3IgPSAnIzAwNzMzNycKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGNvbG9yCiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgYXBwbGljYXRpb246IGl0ZW0uQXBwbGljYXRpb24sCiAgICAgICAgICBzZWN0b3I6IGl0ZW0uU2VjdG9yLnRvTG93ZXJDYXNlKCksCiAgICAgICAgICBlbWlzc2lvbnM6IGVtaXNzaW9uc1ZhbHVlKGRhdGEpLAogICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlVmFsdWUoZGF0YSksCiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25WYWx1ZShkYXRhKSwKICAgICAgICAgIGhlaWdodDogaGVpZ2h0VmFsdWUoZGF0YUhlaWdodCksCiAgICAgICAgICBjb2xvcjogcmVjdENvbG9ycyhkYXRhKSwKICAgICAgICAgIGNsYXNzZXM6IFtpdGVtLkFwcGxpY2F0aW9uLCBpdGVtLlNlY3Rvci50b0xvd2VyQ2FzZSgpLCB7IGhpZGRlbjogc2VsZWN0ZWQgIT09IG51bGwgJiYgc2VsZWN0ZWQgIT09IGl0ZW0uQXBwbGljYXRpb24gfV0KICAgICAgICB9CiAgICAgIH0pCiAgICAgIHJldHVybiBzdWJlbWlzc2lvbkFycmF5CiAgICB9LAogICAgLy8gdGhpcyBvdGhlciBmdW5jdGlvbnMgc3BlY2lmaWNhbGx5IGhhbmRsZSBzZWN0b3IgbGFiZWxzIGZvciBzaW5nbGUgYmFycwogICAgc2VjdG9yTGFiZWxzICgpIHsKICAgICAgY29uc3QgbGFiZWxzID0gWydFbGVjdHJpY2l0eScsICdCdWlsZGluZycsICdJbmR1c3RyeScsICdUcmFuc3BvcnQnXQogICAgICBjb25zdCBjaGFydEFycmF5ID0gdGhpcy5yZWN0cwogICAgICBjb25zdCBFbGVjdHJpY2l0eSA9IGNoYXJ0QXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnNlY3RvciA9PT0gJ2VsZWN0cmljaXR5JyB9KQogICAgICBjb25zdCBJbmR1c3RyeSA9IGNoYXJ0QXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnNlY3RvciA9PT0gJ2luZHVzdHJ5JyB9KQogICAgICBjb25zdCBCdWlsZGluZyA9IGNoYXJ0QXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnNlY3RvciA9PT0gJ2J1aWxkaW5nJyB9KQogICAgICBjb25zdCBUcmFuc3BvcnQgPSBjaGFydEFycmF5LmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5zZWN0b3IgPT09ICd0cmFuc3BvcnQnIH0pCgogICAgICBjb25zdCBuZXdMYWJlbHMgPSBsYWJlbHMubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7CiAgICAgICAgY29uc3QgbGFiZWxOYW1lcyA9IGQgPT4gewogICAgICAgICAgbGV0IG5hbWVzCiAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8PSBpOyBuKyspIHsKICAgICAgICAgICAgbmFtZXMgPSBpdGVtCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbmFtZXMKICAgICAgICB9CgogICAgICAgIGNvbnN0IHBvc2l0aW9uVmFsdWUgPSBkID0+IHsKICAgICAgICAgIGxldCBwb3NpdGlvbgogICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPD0gaTsgbisrKSB7CiAgICAgICAgICAgIGlmIChpdGVtID09PSAnRWxlY3RyaWNpdHknKSB7CiAgICAgICAgICAgICAgcG9zaXRpb24gPSBFbGVjdHJpY2l0eVswXS5wb3NpdGlvbiArIEJ1aWxkaW5nWzBdLnBvc2l0aW9uIC8gMi41CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSA9PT0gJ0J1aWxkaW5nJykgewogICAgICAgICAgICAgIHBvc2l0aW9uID0gQnVpbGRpbmdbMF0ucG9zaXRpb24gKyBCdWlsZGluZ1swXS5wb3NpdGlvbiAvIDcKICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtID09PSAnSW5kdXN0cnknKSB7CiAgICAgICAgICAgICAgcG9zaXRpb24gPSBJbmR1c3RyeVswXS5wb3NpdGlvbiArIEJ1aWxkaW5nWzBdLnBvc2l0aW9uIC8gMi44CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSA9PT0gJ1RyYW5zcG9ydCcpIHsKICAgICAgICAgICAgICBwb3NpdGlvbiA9IFRyYW5zcG9ydFswXS5wb3NpdGlvbiArIEJ1aWxkaW5nWzBdLnBvc2l0aW9uIC8gMwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgc2VjdG9yOiBsYWJlbE5hbWVzKGxhYmVscyksCiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25WYWx1ZShsYWJlbHMpCiAgICAgICAgfQogICAgICB9KQogICAgICByZXR1cm4gbmV3TGFiZWxzCiAgICB9LAogICAgZW5lcmd5Q2FyckxhYmVscyAoKSB7CiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNhcnJpZXJzCiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKQogICAgICB2YXIgbmV3RGF0YSA9IGRhdGEuc2xpY2UoMzMpCgogICAgICBjb25zdCBjYXJyTGFiZWxzID0gbmV3RGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHsKICAgICAgICBjb25zdCBzaW5nbGVDYXJyaWVycyA9IGQgPT4gewogICAgICAgICAgbGV0IHNpbmdsZQogICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPD0gaTsgbisrKSB7CiAgICAgICAgICAgIHNpbmdsZSA9IGl0ZW0uQXBwbGljYXRpb24KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzaW5nbGUKICAgICAgICB9CgogICAgICAgIGNvbnN0IHBvc0xhYmVscyA9IGQgPT4gewogICAgICAgICAgbGV0IHBvc2l0aW9uID0gMAogICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpOyBuKyspIHsKICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiArIDEKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzY2FsZS54UGVyY0xhYmVscyhwb3NpdGlvbikKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGNhcnJpZXI6IHNpbmdsZUNhcnJpZXJzKG5ld0RhdGEpLAogICAgICAgICAgcG9zaXRpb246IHBvc0xhYmVscyhuZXdEYXRhKQogICAgICAgIH0KICAgICAgfSkKCiAgICAgIHJldHVybiBjYXJyTGFiZWxzCiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["marimekko-emissions.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"marimekko-emissions.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"marimekko\">\n  <svg width='100%' height='100%' viewBox='0 0 1100 1000'>\n    <g transform='translate(70,120)' class='rects'>\n      <g id='sector-labels'>\n        <text v-for='(label) in sectorLabels' v-bind:key='label.sector' class='sectorlabel' x='980' :y='label.position' >{{label.sector[0]+'.'}}</text>\n      </g>\n        <rect v-for=\"(rect, i) in rects\" v-bind:key='i' :height='rect.height' :width='rect.emissions' :fill='rect.color' :x='rect.distance' :y='rect.position' class='rect' :class='rect.classes ' :id='rect.application'/>\n      <g id='emissions-labels' v-if='step <= 5'>\n      <line v-for=\"(rect, a) in rects\" :x1='rect.distance' :x2='rect.distance' :y1='rect.position + rect.height' :y2='rect.position + rect.height + 10' class='bars'/>\n      <text v-for=\"(rect, b) in rects\" :x='rect.distance' :y='rect.position + rect.height + 25'>{{rect.application}}</text>\n      </g>\n      <g id='carriers-labels' v-if='step >= 6'>\n      <CarrierPath/>\n      <text v-for=\"(energyCarrLabel, i) in energyCarrLabels\" :id='energyCarrLabel.carrier' :x='energyCarrLabel.position' :y='chartDefaults.height -30' v-bind:key='i' @click='select($event)'>{{energyCarrLabel.carrier}}</text>\n      </g>\n    </g>\n    <!-- Here general axis are created -->\n    <axis transform='translate(70,60)' class='xA' v-bind:scales='getScale().xAxis'  v-bind:chartDefaults='chartDefaults' v-bind:data='subsectors'/>\n    <text transform='translate(430,40)' class='axislabel' v-if='step == 5'>Applications % of emissions (per sector)</text>\n    <text transform='translate(430,40)' class='axislabel' v-if='step >= 6'>Energy Carriers % of produced energy (per sector)</text>\n    <text transform='translate(20,500) rotate(-90)' class='axislabel'>2015 Total GHG Emissions</text>\n    <axis transform='translate(40,120)' class='yA' v-bind:scales='getScale().yAxis'  v-bind:chartDefaults='chartDefaults' v-bind:data='subsectors'/>\n  </svg>\n  </div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\nimport { mapState } from 'vuex'\nimport Axis from './axis.vue'\nimport CarrierPath from './carriersSelPaths.vue'\n\nimport emissionsSubsectors from '../assets/subsectors-emissions-nest.json'\nimport energyCarriers from '../assets/energy-carriers-world.json'\n\nexport default {\n  name: 'marimekkoEmissions',\n  components: {\n    axis: Axis,\n    CarrierPath\n  },\n  data () {\n    return {\n      subsectors: emissionsSubsectors,\n      carriers: energyCarriers,\n      chartDefaults: {\n        width: 1000,\n        height: 700,\n        chartId: 'subemissions',\n        title: 'Emissions',\n        margin: {\n          top: 5,\n          right: 50,\n          bottom: 25,\n          left: 0\n        }\n      },\n      emissionsLabels: this.visibleLabels,\n      selected: null\n    }\n  },\n  methods: {\n    select (event) {\n      var targetId = event.currentTarget.id\n      if (this.selected === targetId) this.selected = null\n      else this.selected = targetId\n    },\n    visibleLabels () {\n      var visible\n      if (this.step === 5) {\n        visible = true\n        return visible\n      } else {\n        visible = false\n        return visible\n      }\n    },\n    getScale () {\n      const subsectors = this.subsectors\n      const carriers = this.carriers\n      const chartDefaults = this.chartDefaults\n      const sectors = ['Electricity', 'Building', 'Industry', 'Transport']\n      var filterEle = subsectors.filter(function (d) { return d.Sector === 'Electricity' })\n      var filterBuild = subsectors.filter(function (d) { return d.Sector === 'Building' })\n      var filterInd = subsectors.filter(function (d) { return d.Sector === 'Industry' })\n      var filterTr = subsectors.filter(function (d) { return d.Sector === 'Transport' })\n\n      var xPerc = d3\n        .scaleLinear()\n        .domain([0, 1])\n        .rangeRound([0, this.chartDefaults.width - 50])\n\n      var xPercLabels = d3\n        .scaleLinear()\n        .domain([0, 10])\n        .rangeRound([0, this.chartDefaults.width - 100])\n\n      var x = d3\n        .scaleLinear()\n        .domain([0, filterEle.reduce((sum, val) => sum + val.Emissions, 0)])\n        .rangeRound([0, this.chartDefaults.width - 50])\n\n      var xB = d3\n        .scaleLinear()\n        .domain([0, filterBuild.reduce((sum, val) => sum + val.Emissions, 0)])\n        .rangeRound([0, this.chartDefaults.width - 50])\n\n      var xI = d3\n        .scaleLinear()\n        .domain([0, filterInd.reduce((sum, val) => sum + val.Emissions, 0)])\n        .rangeRound([0, this.chartDefaults.width - 50])\n\n      var xT = d3\n        .scaleLinear()\n        .domain([0, filterTr.reduce((sum, val) => sum + val.Emissions, 0)])\n        .rangeRound([0, this.chartDefaults.width - 50])\n\n      var scaleXCar = sectors.map(function (item, i) {\n        var scaleArray\n        var carriersScale = carriers.filter(function (d) { return d.Sector === item })\n        for (var n = 0; n <= i; n++) {\n          scaleArray = d3\n            .scaleLinear()\n            .domain([0, carriersScale.reduce((sum, val) => sum + val.Emissions, 0)])\n            .rangeRound([0, chartDefaults.width - 50])\n        }\n        return scaleArray\n      })\n\n      var y = d3\n        .scaleLinear()\n        .domain([0, subsectors.reduce((sum, val) => sum + val.Emissions, 0)])\n        .range([0, this.chartDefaults.height - 300])\n\n      var yA = d3\n        .scaleLinear()\n        .domain([0, subsectors.reduce((sum, val) => sum + val.Emissions, 0)])\n        .range([0, this.chartDefaults.height - 90])\n\n      d3.axisTop().scale(xI)\n      d3.axisRight().scale(yA)\n\n      var formatPercent = d3.format('.0%')\n\n      var xAxis = d3\n        .axisTop()\n        .scale(xPerc)\n        .tickSize(0)\n        .tickPadding(10)\n        .tickValues([0, 1])\n        .tickFormat(formatPercent)\n\n      var yAxis = d3\n        .axisRight()\n        .scale(yA)\n        .ticks(0)\n\n      return {\n        x,\n        xAxis,\n        y,\n        xB,\n        xI,\n        xT,\n        scaleXCar,\n        xPerc,\n        yAxis,\n        xPercLabels\n      }\n    }\n  },\n  // this computed property needs to be added for the scrollytelling to function\n  computed: {\n    ...mapState({\n      step: state => state.scrollytelling ? state.scrollytelling.step : null\n    }),\n    datum () {\n      var step = this.step\n      var data = this.subsectors\n      if (step >= 6) { return this.carriers }\n      return data\n    },\n    // this function creates an array to handle single squares and their vertical height and position on the screen\n    rects () {\n      var scale = this.getScale()\n      var dataHeight = this.subsectors\n      var data = this.datum\n      var step = this.step\n      var selected = this.selected\n\n      const subemissionArray = data.map(function (item, i) {\n        const emissionsValue = d => {\n          let sum = data[0].Emissions\n          for (let n = 0; n < i; n++) {\n            sum = item.Emissions\n          }\n          if (step === 5) {\n            if (item.Sector === 'Electricity') {\n              return scale.x(sum)\n            } else if (item.Sector === 'Building') {\n              return scale.xB(sum)\n            } else if (item.Sector === 'Industry') {\n              return scale.xI(sum)\n            } else if (item.Sector === 'Transport') {\n              return scale.xT(sum)\n            }\n          } else if (step >= 6) {\n            if (item.Sector === 'Electricity') {\n              return scale.scaleXCar[0](sum)\n            } else if (item.Sector === 'Building') {\n              return scale.scaleXCar[1](sum)\n            } else if (item.Sector === 'Industry') {\n              return scale.scaleXCar[2](sum)\n            } else if (item.Sector === 'Transport') {\n              return scale.scaleXCar[3](sum)\n            }\n          }\n        }\n\n        const distanceValue = d => {\n          let total = 0\n          for (let n = 0; n < i; n++) {\n            if (item.Sector === data[n].Sector) {\n              total = total + data[n].Emissions\n            }\n          }\n          if (step === 5) {\n            if (item.Sector === 'Electricity') {\n              return scale.x(total)\n            } else if (item.Sector === 'Building') {\n              return scale.xB(total)\n            } else if (item.Sector === 'Industry') {\n              return scale.xI(total)\n            } else if (item.Sector === 'Transport') {\n              return scale.xT(total)\n            }\n          } else if (step >= 6) {\n            if (item.Sector === 'Electricity') {\n              return scale.scaleXCar[0](total)\n            } else if (item.Sector === 'Building') {\n              return scale.scaleXCar[1](total)\n            } else if (item.Sector === 'Industry') {\n              return scale.scaleXCar[2](total)\n            } else if (item.Sector === 'Transport') {\n              return scale.scaleXCar[3](total)\n            }\n          }\n        }\n\n        const heightValue = d => {\n          let filterEle = dataHeight.filter(function (d) { return d.Sector === 'Electricity' })\n          let filterBuild = dataHeight.filter(function (d) { return d.Sector === 'Building' })\n          let filterInd = dataHeight.filter(function (d) { return d.Sector === 'Industry' })\n          let filterTr = dataHeight.filter(function (d) { return d.Sector === 'Transport' })\n          let height = 0\n          for (let n = 0; n <= i; n++) {\n            if (item.Sector === 'Electricity') {\n              height = filterEle.reduce((sum, val) => sum + val.Emissions, 0)\n            } else if (item.Sector === 'Building') {\n              height = filterBuild.reduce((sum, val) => sum + val.Emissions, 0)\n            } else if (item.Sector === 'Industry') {\n              height = filterInd.reduce((sum, val) => sum + val.Emissions, 0)\n            } else if (item.Sector === 'Transport') {\n              height = filterTr.reduce((sum, val) => sum + val.Emissions, 0)\n            }\n          }\n\n          return scale.y(height)\n        }\n\n        const positionValue = d => {\n          var basisPosition = heightValue()\n          if (item.Sector === 'Electricity') {\n            basisPosition = basisPosition * 0\n          } if (item.Sector === 'Industry') {\n            basisPosition = basisPosition * 2.7\n          } if (item.Sector === 'Building') {\n            basisPosition = basisPosition * 4.5\n          } if (item.Sector === 'Transport') {\n            basisPosition = basisPosition * 5\n          }\n          return basisPosition\n        }\n\n        const rectColors = d => {\n          var color = '#000000'\n          if (step === 5) {\n            if (item.Sector === 'Electricity') {\n              color = '#ffc027'\n            } else if (item.Sector === 'Industry') {\n              color = '#d99900'\n            } else if (item.Sector === 'Building') {\n              color = '#a67500'\n            } else if (item.Sector === 'Transport') {\n              color = '#735100'\n            }\n          } else if (step >= 6) {\n            if (item.Sector === 'Electricity') {\n              color = '#58e4a2'\n            } else if (item.Sector === 'Industry') {\n              color = '#00a66e'\n            } else if (item.Sector === 'Building') {\n              color = '#00c58c'\n            } else if (item.Sector === 'Transport') {\n              color = '#007337'\n            }\n          }\n          return color\n        }\n\n        return {\n          application: item.Application,\n          sector: item.Sector.toLowerCase(),\n          emissions: emissionsValue(data),\n          distance: distanceValue(data),\n          position: positionValue(data),\n          height: heightValue(dataHeight),\n          color: rectColors(data),\n          classes: [item.Application, item.Sector.toLowerCase(), { hidden: selected !== null && selected !== item.Application }]\n        }\n      })\n      return subemissionArray\n    },\n    // this other functions specifically handle sector labels for single bars\n    sectorLabels () {\n      const labels = ['Electricity', 'Building', 'Industry', 'Transport']\n      const chartArray = this.rects\n      const Electricity = chartArray.filter(function (d) { return d.sector === 'electricity' })\n      const Industry = chartArray.filter(function (d) { return d.sector === 'industry' })\n      const Building = chartArray.filter(function (d) { return d.sector === 'building' })\n      const Transport = chartArray.filter(function (d) { return d.sector === 'transport' })\n\n      const newLabels = labels.map(function (item, i) {\n        const labelNames = d => {\n          let names\n          for (let n = 0; n <= i; n++) {\n            names = item\n          }\n          return names\n        }\n\n        const positionValue = d => {\n          let position\n          for (let n = 0; n <= i; n++) {\n            if (item === 'Electricity') {\n              position = Electricity[0].position + Building[0].position / 2.5\n            } else if (item === 'Building') {\n              position = Building[0].position + Building[0].position / 7\n            } else if (item === 'Industry') {\n              position = Industry[0].position + Building[0].position / 2.8\n            } else if (item === 'Transport') {\n              position = Transport[0].position + Building[0].position / 3\n            }\n            return position\n          }\n        }\n        return {\n          sector: labelNames(labels),\n          position: positionValue(labels)\n        }\n      })\n      return newLabels\n    },\n    energyCarrLabels () {\n      const data = this.carriers\n      var scale = this.getScale()\n      var newData = data.slice(33)\n\n      const carrLabels = newData.map(function (item, i) {\n        const singleCarriers = d => {\n          let single\n          for (let n = 0; n <= i; n++) {\n            single = item.Application\n          }\n          return single\n        }\n\n        const posLabels = d => {\n          let position = 0\n          for (let n = 0; n < i; n++) {\n            position = position + 1\n          }\n          return scale.xPercLabels(position)\n        }\n        return {\n          carrier: singleCarriers(newData),\n          position: posLabels(newData)\n        }\n      })\n\n      return carrLabels\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\">\n@import \"library/src/style/variables.scss\";\n\n.bars{\n  stroke: black;\n  stroke-width: 0.7px;\n}\n.electricity {\n  stroke: darken( $color-violet, 5% );\n}\n\n.industry {\n  stroke: darken( $color-violet, 30% );\n\n}\n\n.building{\n  stroke: darken( $color-violet, 20% );\n}\n\n.transport{\n  stroke: darken( $color-violet, 40% );\n}\n\n.sectorlabel {\n  font-size: 18px;\n  font-family: $font-sans;\n}\n\n.hidden {\n  fill: white;\n  opacity: 0.5;\n}\n</style>\n"]}]}