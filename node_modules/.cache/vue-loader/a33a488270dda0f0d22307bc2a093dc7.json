{"remainingRequest":"/Users/francescamorini/projects/transition-module/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/francescamorini/projects/transition-module/src/components/EmissionsChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/francescamorini/projects/transition-module/src/components/EmissionsChart.vue","mtime":1573210462074},{"path":"/Users/francescamorini/projects/transition-module/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/francescamorini/projects/transition-module/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCi8vIExpYnJhcmllcwppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycKCi8vIGNvbXBvbmVudHMKaW1wb3J0IERyYWdsaW5lIGZyb20gJy4vc3ViY29tcG9uZW50cy9EcmFnbGluZS52dWUnCgovLyBEYXRhCmltcG9ydCBlbWlzc2lvbnNEYXRhIGZyb20gJy4uL2Fzc2V0cy9kYXRhL2VtaXNzaW9ucy5qc29uJwppbXBvcnQgc3ViRW1pc3Npb25zRGF0YSBmcm9tICcuLi9hc3NldHMvZGF0YS9lbWlzc2lvbnMtc3RhY2tlZC5qc29uJwppbXBvcnQgQXBwbGljYXRpb25zU2hhcmUgZnJvbSAnLi4vYXNzZXRzL2RhdGEvc3Vic2VjdG9ycy1hcHBsaWNhdGlvbnMtc2hhcmUuanNvbicKLy8gVGhpcyBpcyB0aGUgbmV3IG1vcmUgZ3JhbnVsYXIgZGF0YXNldAppbXBvcnQgSGlzdG9yaWNhbEVtaXNzaW9ucyBmcm9tICcuLi9hc3NldHMvZGF0YS9lbWlzc2lvbnNfaGlzdG9yaWNhbC5qc29uJwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdFbWlzc2lvbnNDaGFydCcsCiAgY29tcG9uZW50czogewogICAgRHJhZ2xpbmUKICB9LAogIHByb3BzOiB7CiAgICB3aWR0aDogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9LAogICAgaGVpZ2h0OiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0sCiAgICBzdGVwOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMAogICAgfQogIH0sCiAgZGF0YSAoKSB7CiAgICByZXR1cm4gewogICAgICBlbWlzc2lvbnNEYXRhLAogICAgICBzdWJFbWlzc2lvbnNEYXRhLAogICAgICBBcHBsaWNhdGlvbnNTaGFyZSwKICAgICAgSGlzdG9yaWNhbEVtaXNzaW9ucywKICAgICAgbWFyZ2luOiB7CiAgICAgICAgbGVmdDogNzAsCiAgICAgICAgdG9wOiAzMCwKICAgICAgICBib3R0b206IDMwLAogICAgICAgIHJpZ2h0OiAzMAogICAgICB9CiAgICB9CiAgfSwKICB3YXRjaDogewogICAgc3RlcDogZnVuY3Rpb24gKHN0ZXApIHsKICAgICAgLy8gY29uc29sZS5sb2coc3RlcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgaW5uZXJXaWR0aCAoKXsKICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQKICAgIH0sCiAgICBpbm5lckhlaWdodCAoKXsKICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW4udG9wIC0gdGhpcy5tYXJnaW4uYm90dG9tCiAgICB9LAogICAgc2NhbGUgKCkgewogICAgICBjb25zdCBlbWlzc2lvbnMgPSB0aGlzLmVtaXNzaW9uc0RhdGEKICAgICAgY29uc3QgcGFyc2VEYXRlID0gZDMudGltZVBhcnNlKCclWScpCiAgICAgIGxldCBtYXhEYXRlID0gcGFyc2VEYXRlKDIwODApCiAgICAgIGlmICh0aGlzLnN0ZXAgPj0gMikgeyBtYXhEYXRlID0gcGFyc2VEYXRlKDIwMTUpIH0KCiAgICAgIGVtaXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgZC5kYXRlID0gcGFyc2VEYXRlKGQuWWVhcikKICAgICAgfSkKCiAgICAgIGxldCB4ID0gZDMKICAgICAgICAuc2NhbGVUaW1lKCkKICAgICAgICAuZG9tYWluKFtkMy5taW4oZW1pc3Npb25zLCBkID0+IGQuZGF0ZSksIG1heERhdGVdKQogICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmlubmVyV2lkdGhdKQoKICAgICAgbGV0IHkgPSBkMwogICAgICAgIC5zY2FsZUxpbmVhcigpCiAgICAgICAgLmRvbWFpbihbMCwgNDAwMDAwMDBdKQogICAgICAgIC5yYW5nZVJvdW5kKFt0aGlzLmlubmVySGVpZ2h0LCAwXSkKCiAgICAgIHJldHVybiB7CiAgICAgICAgcGFyc2VEYXRlLAogICAgICAgIHgsCiAgICAgICAgeQogICAgICB9CiAgICB9LAogICAgbmVzdERhdGEgKCkgewogICAgICAvLyBIZXJlIEkgbmVzdCB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgU2VjdG9yCiAgICAgIGNvbnN0IGVtaXNzaW9ucyA9IHRoaXMuSGlzdG9yaWNhbEVtaXNzaW9ucwogICAgICBjb25zdCBuZXN0ZWRkYXRhID0gZDMubmVzdCgpCiAgICAgICAgLmtleShkID0+IGQuWWVhcikKICAgICAgICAua2V5KGQgPT4gZC5TZWN0b3IpCiAgICAgICAgLmVudHJpZXMoZW1pc3Npb25zKQoKICAgICAgcmV0dXJuIG5lc3RlZGRhdGEKICAgIH0sCiAgICBzdGFja0RhdGEgKCkgewogICAgICBjb25zdCBuZXN0ZWRkYXRhID0gdGhpcy5uZXN0RGF0YQogICAgICBjb25zb2xlLmxvZyhuZXN0ZWRkYXRhKQogICAgICAvLyBJIHdhcyBub3QgYWJsZSB0byBjcmVhdGUgYW4gYXJyYXkgZm9yIGdyb3VwcyB1c2luZyBkMy5ncm91cCgpLCBjb25zb2xlIGVycm9yOiBub3QgYSBmdW5jdGlvbgogICAgICBjb25zdCBncm91cHMgPSBbJ0VsZWN0cmljaXR5JywgJ090aGVyRW5lcmd5JywgJ0luZHVzdHJ5JywgJ1RyYW5zcG9ydHMnLCAnQnVpbGRpbmcnXQogICAgICBjb25zdCBzdGFjayA9IGQzLnN0YWNrKCkKICAgICAgICAua2V5cyhncm91cHMpCiAgICAgICAgLnZhbHVlKGZ1bmN0aW9uIChkLCBrZXkpIHsKICAgICAgICAgIC8vIEhlcmUgSSdtIG5vdCBhYmxlIHRvIHJldHVybiBvbmx5IHRoZSB0b3RhbCBFbWlzc2lvbnMgdmFsdWUgZm9yIHRoZSA1IHNlY3RvcnMKICAgICAgICAgIC8vIHJldHVybiBkLnZhbHVlc1trZXldLkVtaXNzaW9ucwogICAgICAgIH0pKG5lc3RlZGRhdGEpCgogICAgICByZXR1cm4gc3RhY2sKICAgIH0sCiAgICBjYWxjTGluZSAoKSB7CiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZQogICAgICBjb25zdCBlbWlzc2lvbnMgPSB0aGlzLm5lc3REYXRhCiAgICAgIGNvbnN0IHN0YWNrZWQgPSB0aGlzLnN0YWNrRGF0YQogICAgICBjb25zdCBwYXRoID0gZDMKICAgICAgICAubGluZSgpCiAgICAgICAgLngoZCA9PiB7IHJldHVybiBzY2FsZS54KGQuZGF0ZSkgfSkKICAgICAgICAueShkID0+IHsgcmV0dXJuIHNjYWxlLnkoZC5FbWlzc2lvbnMpIH0pCiAgICAgICAgLmN1cnZlKGQzLmN1cnZlTGluZWFyKQogICAgICByZXR1cm4gcGF0aChlbWlzc2lvbnNEYXRhKQogICAgfSwKICAgIHN1YnNlY3RvcnNMYWJlbHMgKCkgewogICAgICBjb25zdCBzdWJzZWN0b3JzID0gdGhpcy5BcHBsaWNhdGlvbnNTaGFyZQogICAgICBsZXQgc3Vic2VjdG9yc0xhYmVscyA9IFtdCgogICAgICBzdWJzZWN0b3JzLnB1c2goc3Vic2VjdG9yc1sxXSkKCiAgICAgIHJldHVybiBzdWJzZWN0b3JzTGFiZWxzCiAgICB9LAogICAgc2VjdG9ycyAoKSB7CiAgICAgIGlmKHRoaXMuc3RlcCA9PT0gMy4xKXsKICAgICAgICByZXR1cm4gWydQdWJsaWMnLCAnQXV0b3Byb2R1Y2VkJywgJ090aGVyRW4nLCAnQ29tYnVzdGlvbicsICdQcm9kdWN0aW9uJywgJ1NvbHZlbnRzJywgJ090aGVyUHJvYycsICdJbmRXYXN0ZScsICdBdmlhdGlvbicsICdSb2FkJywgJ090aGVyJywgJ1NoaXBwaW5nJywgJ0NvbW1SZXMnLCAnQWdyaWN1bHR1cmUnXQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBbJ0VsZWN0cmljaXR5JywgJ090aGVyRW5lcmd5JywgJ0luZHVzdHJ5JywgJ1RyYW5zcG9ydHMnLCAnQnVpbGRpbmcnXQogICAgICB9CiAgICB9LAogICAgZGF0YSAoKSB7CiAgICAgIGlmKHRoaXMuc3RlcCA9PT0gMy4xKXsKICAgICAgICByZXR1cm4gdGhpcy5BcHBsaWNhdGlvbnNTaGFyZQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLnN1YkVtaXNzaW9uc0RhdGEKICAgICAgfQogICAgfSwKICAgIHN1YnNlY3RvcnNTZWxlY3RlZDogZnVuY3Rpb24gKCl7CiAgICAgIGlmKHRoaXMuc3RlcCA9PT0gMy4xKXsKICAgICAgICByZXR1cm4gWydQdWJsaWMnLCAnQXV0b3Byb2R1Y2VkJ10KICAgICAgfQogICAgICByZXR1cm4gW10KICAgIH0sCiAgICBzdWJzZWN0b3JzRGF0YTogZnVuY3Rpb24gKCl7CiAgICAgIHJldHVybiB0aGlzLmRhdGEKICAgIH0sCiAgICBzZWN0b3JDaHVua3MgKCkgewogICAgICBjb25zdCB7IHNlY3RvcnMsIGRhdGEsIHNjYWxlIH0gPSB0aGlzCiAgICAgIGNvbnN0IGNodW5rQ29sb3JzID0gWycjMzMxMjFjJywgJyM2MTE3MzEnLCAnIzkzMTU0NycsICcjZGQ1Zjg0JywgJyNlZDk2YWInXQoKICAgICAgZGF0YS5mb3JFYWNoKChkKSA9PiB7IGQuZGF0ZSA9IHNjYWxlLnBhcnNlRGF0ZShkLlllYXIpIH0pCgogICAgICBjb25zdCBhcmVhc1ggPSBkMwogICAgICAgIC5hcmVhKCkKICAgICAgICAueChkID0+IHsgcmV0dXJuIHNjYWxlLngoZC5kYXRlKSB9KQogICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUxpbmVhcikKCiAgICAgIGNvbnN0IHNlY3RvcnNBcmVhcyA9IHNlY3RvcnMubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7CiAgICAgICAgYXJlYXNYCiAgICAgICAgICAueTAoZCA9PiB7CiAgICAgICAgICAgIGxldCBzdW0gPSAwCiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaTsgbisrKSB7CiAgICAgICAgICAgICAgc3VtID0gc3VtICsgZFtzZWN0b3JzW25dXQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzY2FsZS55KHN1bSkKICAgICAgICAgIH0pCiAgICAgICAgICAueTEoZCA9PiB7CiAgICAgICAgICAgIGxldCBzdW0gPSAwCiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDw9IGk7IG4rKykgewogICAgICAgICAgICAgIHN1bSA9IHN1bSArIGRbc2VjdG9yc1tuXV0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gc2NhbGUueShzdW0pCiAgICAgICAgICB9KQogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkOiBhcmVhc1goZGF0YSksCiAgICAgICAgICBjb2xvcjogY2h1bmtDb2xvcnNbaV0sCiAgICAgICAgICBpZDogc2VjdG9yc1tpXQogICAgICAgIH0KICAgICAgfSkKICAgICAgcmV0dXJuIHNlY3RvcnNBcmVhcwogICAgfQogIH0sCiAgZGlyZWN0aXZlczogewogICAgYXhpcyAoZWwsIGJpbmRpbmcpIHsKICAgICAgY29uc3QgYXhpcyA9IGJpbmRpbmcuYXJnCiAgICAgIGNvbnN0IGF4aXNNZXRob2QgPSB7IHg6ICdheGlzQm90dG9tJywgeTogJ2F4aXNMZWZ0JyB9W2F4aXNdCiAgICAgIGNvbnN0IG1ldGhvZEFyZyA9IGJpbmRpbmcudmFsdWVbYXhpc10KICAgICAgZDMuc2VsZWN0KGVsKQogICAgICAgIC5jYWxsKGQzW2F4aXNNZXRob2RdKG1ldGhvZEFyZykpCiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["EmissionsChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"EmissionsChart.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"visualization\" id=\"emissions__chart\">\n    <svg class=\"emissions\" width=\"100%\" height=\"100%\">\n      <g :transform=\"'translate('+ margin.left + ',' + margin.top + ')'\">\n        <g class=\"axis\" v-axis:x=\"scale\" :transfrom=\"'translate('+ 0 + ',' + this.innerHeight + ')'\"></g>\n        <g class=\"axis\" v-axis:y=\"scale\"></g>\n        <g id=\"first_step\" v-show=\"step <= 2\">\n          <path id=\"emissions\" :d='calcLine' />\n        </g>\n        <g id=\"second_step\" v-show=\"step >=3\">\n          <path\n            v-for=\"(chunk, i) in sectorChunks\"\n            v-bind:key='i'\n            :d='chunk.d'\n            :fill='chunk.color'\n            :id='chunk.id'\n            class=\"emission__chunks\"\n          />\n       </g>\n       <dragline :width=\"this.innerWidth\" :margin=\"margin\" :height=\"this.innerHeight\" :scale=\"scale\" :data=\"subsectorsData\" />\n    </g>\n    </svg>\n  </div>\n</template>\n\n<script>\n// Libraries\nimport * as d3 from 'd3'\n\n// components\nimport Dragline from './subcomponents/Dragline.vue'\n\n// Data\nimport emissionsData from '../assets/data/emissions.json'\nimport subEmissionsData from '../assets/data/emissions-stacked.json'\nimport ApplicationsShare from '../assets/data/subsectors-applications-share.json'\n// This is the new more granular dataset\nimport HistoricalEmissions from '../assets/data/emissions_historical.json'\n\nexport default {\n  name: 'EmissionsChart',\n  components: {\n    Dragline\n  },\n  props: {\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    },\n    step: {\n      type: Number,\n      default: 0\n    }\n  },\n  data () {\n    return {\n      emissionsData,\n      subEmissionsData,\n      ApplicationsShare,\n      HistoricalEmissions,\n      margin: {\n        left: 70,\n        top: 30,\n        bottom: 30,\n        right: 30\n      }\n    }\n  },\n  watch: {\n    step: function (step) {\n      // console.log(step, this.width, this.height)\n    }\n  },\n  computed: {\n    innerWidth (){\n      return this.width - this.margin.left - this.margin.right\n    },\n    innerHeight (){\n      return this.height - this.margin.top - this.margin.bottom\n    },\n    scale () {\n      const emissions = this.emissionsData\n      const parseDate = d3.timeParse('%Y')\n      let maxDate = parseDate(2080)\n      if (this.step >= 2) { maxDate = parseDate(2015) }\n\n      emissions.forEach(function (d) {\n        d.date = parseDate(d.Year)\n      })\n\n      let x = d3\n        .scaleTime()\n        .domain([d3.min(emissions, d => d.date), maxDate])\n        .rangeRound([0, this.innerWidth])\n\n      let y = d3\n        .scaleLinear()\n        .domain([0, 40000000])\n        .rangeRound([this.innerHeight, 0])\n\n      return {\n        parseDate,\n        x,\n        y\n      }\n    },\n    nestData () {\n      // Here I nest the data based on the Sector\n      const emissions = this.HistoricalEmissions\n      const nesteddata = d3.nest()\n        .key(d => d.Year)\n        .key(d => d.Sector)\n        .entries(emissions)\n\n      return nesteddata\n    },\n    stackData () {\n      const nesteddata = this.nestData\n      console.log(nesteddata)\n      // I was not able to create an array for groups using d3.group(), console error: not a function\n      const groups = ['Electricity', 'OtherEnergy', 'Industry', 'Transports', 'Building']\n      const stack = d3.stack()\n        .keys(groups)\n        .value(function (d, key) {\n          // Here I'm not able to return only the total Emissions value for the 5 sectors\n          // return d.values[key].Emissions\n        })(nesteddata)\n\n      return stack\n    },\n    calcLine () {\n      const scale = this.scale\n      const emissions = this.nestData\n      const stacked = this.stackData\n      const path = d3\n        .line()\n        .x(d => { return scale.x(d.date) })\n        .y(d => { return scale.y(d.Emissions) })\n        .curve(d3.curveLinear)\n      return path(emissionsData)\n    },\n    subsectorsLabels () {\n      const subsectors = this.ApplicationsShare\n      let subsectorsLabels = []\n\n      subsectors.push(subsectors[1])\n\n      return subsectorsLabels\n    },\n    sectors () {\n      if(this.step === 3.1){\n        return ['Public', 'Autoproduced', 'OtherEn', 'Combustion', 'Production', 'Solvents', 'OtherProc', 'IndWaste', 'Aviation', 'Road', 'Other', 'Shipping', 'CommRes', 'Agriculture']\n      } else {\n        return ['Electricity', 'OtherEnergy', 'Industry', 'Transports', 'Building']\n      }\n    },\n    data () {\n      if(this.step === 3.1){\n        return this.ApplicationsShare\n      } else {\n        return this.subEmissionsData\n      }\n    },\n    subsectorsSelected: function (){\n      if(this.step === 3.1){\n        return ['Public', 'Autoproduced']\n      }\n      return []\n    },\n    subsectorsData: function (){\n      return this.data\n    },\n    sectorChunks () {\n      const { sectors, data, scale } = this\n      const chunkColors = ['#33121c', '#611731', '#931547', '#dd5f84', '#ed96ab']\n\n      data.forEach((d) => { d.date = scale.parseDate(d.Year) })\n\n      const areasX = d3\n        .area()\n        .x(d => { return scale.x(d.date) })\n        .curve(d3.curveLinear)\n\n      const sectorsAreas = sectors.map(function (item, i) {\n        areasX\n          .y0(d => {\n            let sum = 0\n            for (let n = 0; n < i; n++) {\n              sum = sum + d[sectors[n]]\n            }\n            return scale.y(sum)\n          })\n          .y1(d => {\n            let sum = 0\n            for (let n = 0; n <= i; n++) {\n              sum = sum + d[sectors[n]]\n            }\n            return scale.y(sum)\n          })\n        return {\n          d: areasX(data),\n          color: chunkColors[i],\n          id: sectors[i]\n        }\n      })\n      return sectorsAreas\n    }\n  },\n  directives: {\n    axis (el, binding) {\n      const axis = binding.arg\n      const axisMethod = { x: 'axisBottom', y: 'axisLeft' }[axis]\n      const methodArg = binding.value[axis]\n      d3.select(el)\n        .call(d3[axisMethod](methodArg))\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n@import \"library/src/style/variables.scss\";\n.visualization {\n  width: inherit;\n  height: inherit;\n}\n\nsvg {\n  // position: absolute;\n  // top: 10vh;\n}\n\n#emissions {\n  stroke: $color-red;\n  fill: none;\n}\n\n.emission__chunks {\n  stroke: $color-red;\n}\n</style>\n"]}]}